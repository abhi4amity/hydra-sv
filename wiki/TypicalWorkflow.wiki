#summary Below is a description of a typical workflow/pipeline for detecting SV breakpoints with Hydra
#labels Featured

<br>

*Overview.*  
The pipeline described below is meant to describe a general approach that we have found to be effective for discovering SV breakpoints with Hydra. However, it should be noted that this approach seeks to discover breakpoints arising from both "unique" *and duplicated* (e.g., segmental duplications, recent retrotransposons).  Therefore, it includes a final step (Tier 3) that attempts to capture *mappings* for readpairs that align to such duplicated sequences.  Hydra then uses those mappings to search for transposon insertions and rearrangements among segmental duplications.  If you are not interested in these types of events, you can eliminate the Tier 3 alignment step.

*Why tiered alignment?*
We employ a tiered alignments strategy in order to optimize the tradeoff between alignment speed and sensitivity.  Clearly, we could just skip the first two tiers described below and simply align all readpairs with the extremely sensitive settings for Tier 3.  The problem is that this can take an extremely long time for large datasets.  A tiered alignment approach begins with a fast aligner to quickly identify "proper pairs" or "concordant pairs".  We then scrutinize the remaining "improper or discordant" pairs with a more sensitive aligner.  The motivation here is that the aligner from the first tier didn't have the sensitivity to identify that a discordant is actually concordant alignments.


*A note on aligners*
The pipeline below is based upon BWA and Novoalign, but is not meant to suggest that these are the only tools that are possible to use for SV analysis with Hydra.  For tier 1, other aligners such as Bowtie or Mosaik could easily be used.  For tier 2 alignment, we suggest a slower, hash-based aligner using a small hash/kmer size (e.g. 12-14 bp), as you want this step to be more sensitive so that you can remove concordants that were missed in tier 1.  Mosaik and BFAST be good alternatives here.  As for tier 3, we have found that very few aligners will actually report multiple mappings for discordant pairs in SAM format.  This is a requirement for Hydra in order to detect SV in duplicated sequence.  Our experience is that Novoalign works well.  The downside is that the freely-available version of Novoalign is rather slow.  We are looking into the use of MrFast as a freely-available alternative.



*An example pipeline*

  # *Tier 1 alignment*. Align your paired-end reads to the reference genome with a fast and reasonably sensitive aligner (e.g.,  [http://bio-bwa.sourceforge.net/ BWA] or [http://bowtie-bio.sourceforge.net/index.shtml Bowtie]). This step serves as an initial pass towards identifying concordant pairs.
  # *Tier 2 alignment*. Grab the discordant alignments from the *tier 1* BAM files and create FASTQ files for the discordant pairs.  Align the tier 1 discordant pairs with a more sensitive aligner such as [http://www.novocraft.com Novoalign] or [http://code.google.com/p/mosaik-aligner/ Mosaik] using a word size of no more than 15bp (we typically use 11-14 with Novoalign at this stage). We find this to be a necessary step as many concordant pairs are missed in the first tier (a consequence of the tradeoff b/w speed and senitivity). In turn, these missed concordant pairs lead to false positive SV calls. At this point, you are merely trying to eliminate remaining concordant pairs.  Thus, if using Novoalign, you should use the "-r Random" alignment mode.  Below is an example for creating discordant FASTQ files from the tier1 discordant alignments:
{{{
$ samtools view -bF 0x2 <tier1.bam> | bamToFastq -bam stdin -fq1 tier1.disc.1.fq -fq2 tier1.disc.2.fq 
}}}
  # *Tier 3 alignment*.  Grab the discordant alignments from the *tier 2* BAM files and create FASTQ files for the discordant pairs. Align the tier 2 discordant pairs with the same aligner from step 2 (or a more sensitive tool if you have the CPU cycles).  In this stage, however, we want to track *_all_* discordant alignment positions and use even more sensitive parameters such that any remaining "crypic" concordant pairs are detectable.  Retaining multiple mapping positions for the discordant pairs will allow us to detect SV involving duplicated/repetitive sequences such as segmental duplications and transposable elements.  Clearly this is an optional step: if you don't care about SV in duplicated sequence, only retain uniquely aligned reads---Hydra will work nonetheless.  If possible (i.e, if you have a sufficient number of CPUs), you should decrease the word size used for alignment to further eliminate remaining concordant pairs that may exist solely because a larger alignment seed was previously missed owing to sequence errors and/or polymorphism.  If using Novoalign, we recommend the following settings: -rE and -t at least 180, perhaps up to 300.
{{{
$ samtools view -bF 0x2 <tier2.bam> | bamToFastq -bam stdin -fq1 tier2.disc.1.fq -fq2 tier2.disc.2.fq 
}}}
  # *Create all discordant mapping combinations for each discordant read-pair.* Use the pairDiscordants.py script to screen for remaining concordant pairs and for all discordant pairs, create the mapping combinations for SV detection with Hydra.  pairDiscordants.py allows you to set the upper (-z) and lower (-y) bound for concordants (this should be derived by plotting the alignment distance of your pairs and computing median and m.a.d. values).  It also allows you to set the maximum number of mapping positions allowed for a given discordant pair.  We typically set this to 1000 (-n).  Use the "-m hydra" option to create output that is appropriate for use with Hydra. 
{{{
$ bamToBed -i tier3.disc.nameSorted.bam -tag NM | pairDiscordants.py -i stdin -m hydra [OPTIONS] > disc.bedpe
}}}
  # *Remove alignments where both ends are in simple sequence repeats (opt., but strongly suggested).* SSRs and VNTRs are hyper-variable and prone to misassembly.  Consequently, a substantial number of spurious variants are often observed owing to SSR misassembly if mappings that touch SSRs on both ends are not removed prior to Hydra. We recommend using the pairToBed utility in BEDTools to do this.
{{{
$ pairToBed -a disc.bedpe -b SSRs.bed -type notboth | cut -f 1-12 > disc.noSSR.bedpe
}}}
  # *Remove PCR and sequencing duplicates.*
{{{
$ dedupDiscordants.py -i disc.noSSR.bedpe [OPTIONS] > disc.noSSR.deduped.bedpe
}}}
  # *Detect SV breakpoints with Hydra*
{{{
$ hydra -i disc.deduped.noSSR.deduped.bedpe [OPTIONS]
}}}
  # *Characterize/classify Hydra breakpoints with [http://code.google.com/p/bedtools BEDTools], Galaxy, UCSC Genome Browser, etc.* For example, use transposon annotations to distinguish true deletions in an experimental genome versus transposon insertions in the reference genome.